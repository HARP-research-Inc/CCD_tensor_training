\\documentclass{article}
\\usepackage{amsmath,amssymb,amsthm}
\\usepackage{enumitem}

%-----------------------------------------------------------------
% theorem‑like environments
%-----------------------------------------------------------------
\\newtheorem{definition}{Definition}
\\newtheorem{axiom}{Axiom}
\\newtheorem{proposition}{Proposition}
\\newtheorem{theorem}{Theorem}
\\newtheorem{corollary}{Corollary}
\\newtheorem{example}{Example}
\\newtheorem{remark}{Remark}

\\title{Thread--Equivalence Posets (TE--posets) and Rail--Switch Geometry}
\\author{}
\\date{}

\\begin{document}
\\maketitle

%=================================================================
\\section{Core notion}

\\begin{definition}[TE‑poset]\label{def:TE}
A \emph{thread--equivalence poset} (TE‑poset) is a triple
\[
  \mathcal P \;=\;(P,\le,T)
\]
where $P$ is a finite set of \emph{vertices}, $\le$ a preorder on~$P$,
and $T$ a partition of~$P$ into \emph{threads}.  Denote the block of
$x$ by $\operatorname{thr}(x)$.  The axioms are
\begin{enumerate}[label=\textbf{T\arabic*}, wide]
  \item\label{ax:t1} \textbf{Thread partition.} $T$ is a partition of~$P$.
  \item\label{ax:t2} \textbf{Linearity inside threads.} Each induced
        order $(S,\le)$ with $S\in T$ is a chain.
  \item\label{ax:t3} \textbf{No strict cross‑thread order.}  If
        $x\le y$ and $\operatorname{thr}(x)\neq\operatorname{thr}(y)$ then
        $y\le x$ also holds.
\end{enumerate}
Write $x\sim y$ when $x\le y\le x$.
\\end{definition}

\\begin{remark}
Quotienting by $\sim$ collapses every thread to a point and produces a
\emph{weak order} (chain of antichains).  A TE‑poset therefore refines
such a weak order by internal linear chains and a chosen set of
cross‑thread equivalences.
\\end{remark}

%=================================================================
\\section{Rank‑aligned TE‑posets (rail--switch posets)}

For rail‑switch drawings each equivalence must join vertices on the
\emph{same} rank.  We add one more axiom.

\\begin{definition}[RS‑poset]\label{def:RS}
An \emph{RS‑poset} is a TE‑poset $\mathcal P=(P,\le,T)$ together with a
rank map $\rho:P\to\mathbb N$ satisfying
\begin{enumerate}[label=\textbf{T4}, wide]
  \item\label{ax:t4} \textbf{Rank alignment.}  For $x<y$ in a thread
    one has $\rho(x)<\rho(y)$; for $x\sim y$ with
    $\operatorname{thr}(x)\neq\operatorname{thr}(y)$ one has
    $\rho(x)=\rho(y)$.
\end{enumerate}
Write $\operatorname{col}(x)=i$ when $x\in S_i\in T$.
\\end{definition}

\\begin{remark}
With T1--T4 the covering graph contains \emph{only} vertical in‑thread
edges and horizontal two‑cycles; the ASCII "rail‑switch" motif is
therefore canonical.
\\end{remark}

%-----------------------------------------------------------------
\\subsection{Canonical rail‑switch embedding}

\\begin{proposition}[Grid embedding]\label{prop:grid}
Let $T=\{S_0,\dots,S_{m-1}\}$ be enumerated.  Place each
$v\in S_i$ at $(\operatorname{col}v,\rho(v))=(i,\rho(v))\in\mathbb Z^2$;
connect successive ranks $\rho= r\to r{+}1$ vertically and every
equivalent pair horizontally.  No two edges cross; hence every
RS‑poset admits a planar straight‑line drawing.
\\end{proposition}

\\begin{proof}
Vertical edges occupy distinct $x$‑coordinates; horizontals lie on
distinct $y$‑coordinates and span only between adjacent strips.  Edge
interiors are therefore disjoint.
\\end{proof}

%=================================================================
\\section{Rail‑switch diagrams as graphs}

\\begin{definition}[Rail‑switch diagram]\label{def:RSD}
A \emph{rail‑switch diagram} is a finite digraph $D=(V,E_v\cup E_h)$
with an injective placement $\pi:V\to\mathbb N\times\mathbb N$ such
that
\begin{enumerate}[label=\textbf{R\arabic*}, wide]
  \item\label{ax:r1} $E_v=\{((c,r),(c,r{+}1))\mid(c,r)\in\pi(V)\}$;
  \item\label{ax:r2} $E_h\subseteq\{((c,r),(c',r))\mid c\neq c'\}$;
  \item\label{ax:r3} if $e\in E_h$ then $e^{\mathrm{op}}\in E_h$.
\end{enumerate}
Call $V_c=\pi^{-1}(\{c\}\times\mathbb N)$ a \emph{rail} and
$H_r=\pi^{-1}(\mathbb N\times\{r\})$ a \emph{track level}.
\\end{definition}

%-----------------------------------------------------------------
\\subsection{From diagrams to posets}

Given $D$ define $x\le_D y$ when a directed path $x\leadsto y$ exists.
Axioms R1--R3 make $(V,\le_D)$ an RS‑poset with
$\operatorname{thr}(x)=\operatorname{col}\pi(x)$ and
$\rho(x)=\operatorname{row}\pi(x)$.  Denote this functor
$P(D)$.

%-----------------------------------------------------------------
\\subsection{From posets to diagrams}

Conversely, for an RS‑poset $(P,\le,T,\rho)$ let $\pi(v)=(i,\rho(v))$
for the unique $S_i\in T$ containing $v$.  Define $E_v,E_h$ as in
\ref{ax:r1}--\ref{ax:r2}.  The result $D(P)$ obeys R1--R3 by the rank
axiom.

%-----------------------------------------------------------------
\\subsection{Equivalence theorem}

\\begin{theorem}[RS‑posets \& diagrams]\label{thm:equiv}
The assignments $D\mapsto P(D)$ and $P\mapsto D(P)$ are mutually
inverse up to isomorphism.  Therefore the category of finite
RS‑posets\,/\,rank‑preserving embeddings is equivalent to the category
of rail‑switch diagrams\,/\,graph embeddings preserving $\pi$.
\\end{theorem}

\\begin{proof}[Sketch]
Composing $D\mapsto P(D)\mapsto D(P(D))$ fixes both vertex set and
coordinates, hence yields a diagram isomorphic to $D$.  Conversely,
$P\mapsto D(P)\mapsto P(D(P))$ reconstructs the same preorder and rank
function, producing a poset isomorphic to $P$.
\\end{proof}

%=================================================================
\\section{Operations and dynamics}

The primitive mutations of \S\ref{def:ops} act dually on diagrams:
\begin{center}
\begin{tabular}{l|l}
RS‑poset operation & Rail‑switch diagram move \\
\hline
\textsc{addThread} & add a new vertical rail (new column) \\
\textsc{insertBetween} & subdivide a vertical segment, shift vertices above \\
\textsc{formEquiv} & insert a horizontal two‑cycle at level $\rho$ \\
\textsc{breakEquiv} & delete a horizontal two‑cycle
\end{tabular}
\end{center}
These moves preserve R1--R3 and hence stay within the class of
diagrams, mirroring closure of RS‑posets under the same operations.

%=================================================================
\\section{Example}

Take threads $S_0=\{a<b<c\}$, $S_1=\{d<e\}$ with
$a\sim d$ and $c\sim e$.  Assign $\rho(a)=\rho(d)=0$, $\rho(b)=1$,
$\rho(c)=\rho(e)=2$.  Its rail‑switch diagram is
\[
  \begin{array}{c@{\quad}c}
    a&d\\[-2pt]
    |&|\\[-2pt]
    b&\\[-2pt]
    |&|\\[-2pt]
    c&e
  \end{array}
\]
Removing the sleeper $c\leftrightarrow e$ would violate
\ref{ax:t4}, hence the diagram lives genuinely in the RS class.

%=================================================================
\section{The Hasse-quiver functor}\label{sec:hasse-quiver}

We now show how every RS–poset can be faithfully represented as a quiver
carrying exactly its covering relations and equivalences.

\begin{definition}[Hasse-quiver]\label{def:hasse-quiver}
Let \(\mathcal P=(P,\le,T,\rho)\) be a finite RS-poset.  Its
\emph{Hasse-quiver} \(F(\mathcal P)\) is the quiver
\[
  \bigl(Q_0,Q_1,\mathrm{src},\mathrm{tgt}\bigr)
\]
defined by
\[
  Q_0 = P,
  \qquad
  Q_1 =
    \bigl\{(x,y)\in P\times P : x\prec y\bigr\}
  \;\cup\;\bigl\{(x,y),(y,x):x\sim y,\;x\neq y\bigr\},
\]
where \(x\prec y\) means that \(y\) \emph{covers} \(x\) in \(\mathcal P\)
(i.e.\ \(x<y\) and there is no \(z\) with \(x<z<y\)).  The maps
\(\mathrm{src},\mathrm{tgt}:Q_1\to Q_0\) are
\(\mathrm{src}(x,y)=x,\;\mathrm{tgt}(x,y)=y\).
\end{definition}

\begin{definition}[Functor on morphisms]\label{def:hasse-func}
A rank-preserving order-embedding
\(f\colon(P,\le,T,\rho)\to(P',\le',T',\rho')\) induces a quiver map
\[
  F(f)\colon F(\mathcal P)\;\longrightarrow\;F(\mathcal P'),
  \quad
  F(f)(v)=f(v),\;
  F(f)( (x,y) )=(f(x),f(y)).
\]
Because \(f\) preserves covers and equivalences (and ranks), \(F(f)\)
is well-defined and commutes with \(\mathrm{src}\) and \(\mathrm{tgt}\).
\end{definition}

\begin{proposition}
The assignments \(\mathcal P\mapsto F(\mathcal P)\) and
\(f\mapsto F(f)\) define a fully faithful functor
\[
  F\colon \mathbf{RSPoset}\;\longrightarrow\;\mathbf{Quiv}.
\]
Its essential image consists exactly of those quivers whose vertices
carry integer \((\mathrm{col},\rho)\) labels and whose arrows are either
vertical covers or horizontal two-cycles at constant \(\rho\).
\end{proposition}

\begin{proof}[Sketch]
\emph{Faithfulness:} distinct embeddings \(f\neq g\) differ on some
vertex \(v\), hence \(F(f)\neq F(g)\) on \(v\).  
\emph{Fullness:} any quiver map preserving the grid labelling arises
from a unique RS-poset map.  
\emph{Essential image:} precisely those quivers whose arrows can be
read off as “up one rank in a column” or “two-headed on a single row.”
\end{proof}

\begin{remark}[Computational construction]
In Python one may implement
\texttt{RSPoset.to\_quiver()} by:
\begin{enumerate}
  \item Computing all covering pairs \(\{(x,y):x\prec y\}\).
  \item Adding each two-cycle \((x,y),(y,x)\) for \(x\sim y\).
  \item Packaging vertices \(P\), arrows \(Q_1\), and source/target
        maps into a \texttt{quiver} instance.
\end{enumerate}
This functorial embedding allows one to leverage quiver‐based tools
(e.g.\ path-algebra methods, visualisation libraries) on RS-posets.
\end{remark}


%=================================================================
\\section{Outlook}

Open problems include counting formulas for RS‑posets, optimisation of
rank maintenance under bulk mutations, and categorical semantics via
string diagram calculi for distributed synchrony.

\\end{document}
